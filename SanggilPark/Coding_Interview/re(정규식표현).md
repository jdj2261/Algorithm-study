### [파이썬] 정규표현식(regular experession)

## 정규표현식

정규표현식은 특정 문자열이나 문장 안에서 나만의 규칙을 만들어 어떤 단어나 값들을 식별하고 싶을때 사용되는 표현이다. 파이썬에서 이러한 정규표현식을 지원하기 위해 re(regular expression)모듈을 제공한다.



## 1. 정규표현식 생성 방식

정규표현식을 사용하는 방법은 크게 두가지가 있다.

미리 컴파일 후 패턴을 저장해놓는 경우와, 함수를 사용할때 마다 직접 넣어주는 경우가 있다.

### 1-1. 컴파일 후 매칭

~~~python
import re
p = re.compile('[a-z]+') # compile 메서드 사용
m = p.match("python") # 패턴 객체(p)에 검색 메서드가 있다.
~~~

- 컴파일을 활용하는 경우, 한 줄 더 써야 하지만 패턴 객체(p)를 만들고 나면 여러번 재사용 가능하다.
- 반복적인 매칭 작업이 필요할 경우 패턴을 미리 컴파일하여 시간을 단축시킬 수 있다.

### 1-2. 축약형

~~~python
import re
source = "Lux, the Lady of Luminoisty"
m = re.match('[a-z]+', source) # 컴파일과 매치를 한번에 했다.
~~~

- 패턴을 컴파일하지 않고 바로 적용가능하다.

## 2. 메타 문자

정규표현식을 사용하려면 메타문자를 이해하고 꼭 암기하자.

| 메타 문자 | 설명                                                        |
| :-------: | :---------------------------------------------------------- |
|    [ ]    | 문자 클래스                                                 |
|     .     | `\n`을 제외한 모든 문자와 매치 (점 하나는 글자 하나를 의미) |
|     *     | 0회 이상 반복 (생략 가능)                                   |
|     +     | 1회 이상 반복                                               |
|  {m, n}   | m회 이상 n회 이하                                           |
|     l     | or 조건식을 의미                                            |
|     ^     | 문자열의 시작 의미                                          |
|     $     | 문자열의 끝을 의미                                          |
|     ?     | 0회 이상 1회 이하                                           |
|     \     | 이스케이프, 또는 메타 문자를 일반 문자로 인식하게 한다      |
|    ( )    | 그룹핑, 추출할 패턴을 지정한다.                             |

### 2-1. [] 문자클래스

세 가지 특징을 기억하자.

- 대괄호 안에는 어떤 것이든 들어갈 수 있다. (대소문자 구별)

- 안에 들어간 것 끼리 or로 연결된다.(하이픈 '-'로 연결)

- 만약 [abc]라면 'a','b','c' 중 한 개의 문자와 매칭된다. 

  [a-z]는 a~z 문자, [0-9]는 0~9까지 숫자를 말한다.

### 2-2. 문자클래스 축약표현

메타문자 [] 만으로 표현하기에는 한계가 있다.

아래의 표현을 알아두자.

|  원래 표현식   | 축약 표현 | 부연 설명                                                    | 사용처                             |
| :------------: | :-------: | :----------------------------------------------------------- | :--------------------------------- |
|     [0-9]      |    \d     | 숫자를 찾는다                                                | 숫자                               |
|     [^0-9]     |    \D     | 숫자가 아닌 것을 찾는다                                      | 텍스트 + 특수문자 + 화이트스페이스 |
| [ \t\n\r\f\v]  |    \s     | whitespace 문자인 것을 찾는다                                | 스페이스, TAB, 개행(new line)      |
| [^ \t\n\r\f\v] |    \S     | whitespace 문자가 아닌 것을 찾는다                           | 텍스트 + 특수문자 + 숫자           |
|  [a-zA-Z0-9]   |    \w     | 문자+숫자인 것을 찾는다. (특수문자는 제외. 단, 언더스코어 포함) | 텍스트 + 숫자                      |
|  [^a-zA-Z0-9]  |    \W     | 문자+숫자가 아닌 것을 찾는다.                                | 특수문자 + 공백                    |

> Tip1 : 대문자는 소문자의 반대 역할을 한다.
>
> Tip2 : 보통 ^문자열은 맨 처음과 일치함을 의미하지만, 문자 클래스 [ ^문자열 ]에서는 not의 의미다.

- Dot(.) : \n 을 제외한 모든 문자와 메칭된다.

  도트 하나는 문자 하나를 의미하고, 두개는 문자 두개를 의미한다.

  > Tip 1 : 문자는(0-9)나 특수문자(!@#$%^& 등)을 포함한다.

- 반복 * : * 바로 앞 문자가 0번 이상 반복

| 표현식 | 설명                                                         |                          매칭 예시                           |
| :----- | :----------------------------------------------------------- | :----------------------------------------------------------: |
| .*     | 선행문자가 `.`이므로 하나 이상의 문자를 포함하는 문자열(공백 문자열 제외) | 모든 문자가 출력될 거라고 생각하기 쉽지만, `.`이 공백 문자열은 제외하기 때문에 첫줄만 출력된다. 모두 선택을 하고자 한다면 `.+`로 출력하는 것이 적절해보인다.` |
| ab*c   | b를 0번 또는 여러번 반복되도 상관없음                        |                     ac, az, a123c, abbbb                     |
| like.* | 선행문자가 `.`이므로 like에 0 또는 하나 이상의 문자가 추가된 문자열 |                   like, likely ,likelihood                   |

- 반복 + : + 바로 앞 문자가 1번 이상 반복

  - 애스터리스크(*)는 0번 이상 반복될 수 있다는 의미라면,

    (+)는 선행문자가 무조건 1번 이상 등장해야 한다.

    +를 붙여야 온전한 단어처럼 출력되며, +와 *의 차이를 꼭 알자

| 표현식 | 설명                                                         |             매칭 예시              |
| :----- | :----------------------------------------------------------- | :--------------------------------: |
| ca+t   | a가 1번 이상 반복되야 함                                     |      cat, caaaat, caaaaaaaat       |
| car+ot | r이 1번 이상 반복되어야 함                                   |               carrot               |
| like.+ | 선행문자가 `.`이므로 like에 하나 이상 문자열이 추가되어야 함 | liekly, liker (단, like는 안된다.) |
| [A-Z]+ | 대문자로만 이루어진 문자열                                   |           ABC, DEF, ZAX            |

~~~python
source = "Luke Skywarker 02-123-4567 luke@daum.net"  # \w와 \w+의 차이 
 
m1 = re.findall('\w', source) # 단어가 아니라 문자 단위로 출력 
m2 = re.findall('\w+', source) # 단어 단위로 출력 
print("m1 : ", m1)
print("m2 : ", m2)

>>> 출력결과
m1 :  ['L', 'u', 'k', 'e', 'S', 'k', 'y', 'w', 'a', 'r', 'k', 'e', 'r', '0', '2', '1', '2',&nbnbsp;'3', '4', '5', '6', '7', 'l', 'u', 'k', 'e', 'd', 'a', 'u', 'm', 'n', 'e', 't']
m12 :  ['Luke', 'Skywarker', '02', '123', '4567', 'luke', 'daum', 'net']
~~~

- 반복 {} : 바로 앞 문자의 반복횟수 지정

| 표현식     | 설명                                 |  "ct cat caat caaat caaaat"  |
| :--------- | :----------------------------------- | :--------------------------: |
| ca{2}t     | a가 2회 반복되어야 함                |             caat             |
| ca{2,5}t   | a가 2회 이상 5회 이하 반복되어야 함  |     caat, caaat, caaaat      |
| ca{0, }t   | 반복횟수 0회 이상 (`*`와 동일)       | ct, cat, caat, caaat, caaaat |
| cat{0, 1}t | 반복횟수 0회 ~ 1회 이하 (`?`와 동일) |           ct, cat            |
| cat{ , 3}  | 반복횟수 0회 이상 ~ 3회 이하         |     ct, cat, caat, caat      |

```python
import re
 
source = "ct cat caat caaat caaaat"
m1 = re.findall("ca{2}t", source)
m2 = re.findall("ca{2,5}t", source)
m3 = re.findall("ca{0,}t", source)
m4 = re.findall("ca{0,1}t", source)
m5 = re.findall("ca{,3}t", source)
print("m1 : ", m1)
print("m2 : ", m2)
print("m3 : ", m3)
print("m4 : ", m4)
print("m5 : ", m5)
 
>>>출력결과
m1 :  ['caat']
m2 :  ['caat', 'caaat', 'caaaat']
m3 :  ['ct', 'cat', 'caat', 'caaat', 'caaaat']
m4 :  ['ct', 'cat']
m5 :  ['ct', 'cat', 'caat', 'caaat']
```

- 반복 ? : 반복횟수 {0,1}를 의미하며, 선행문자가 없어도 된다.

| 표현식 | 설명                         |  예시   |
| :----- | :--------------------------- | :-----: |
| ab?c   | b가 있어도 되고 없어도 된다. | ac, abc |

```python
import re
 
source = "ct cat caat caaat caaaat"
m1 = re.findall("ca?", source)
print("m1 : ", m1)
 
>>> 출력결과
m1 :  ['c', 'ca', 'ca', 'ca', 'ca']
```

### 2-3. () : 그룹핑

~~~python
p = re.compile("(\w*)\s+(\w{2}-/w*)")
m = p.search("my name is yg-analyst")
print(m.group(0))
print(m.group(1))
print(m.group(2))
~~~

~~~python
[Output]
is yg-anlalyst
is
yg-analyst
~~~

위 정규표현식에 ()를 두개 넣어 두 그룹으로 만들었다.

- () 고려하지 않고 해당 정규표현식으로 우선 탐색 => group(0)에 저장
- group(0)에 저장된 표현 중 첫번째 ()에 해당하는 문자열 => group(1)에 저장
- group(0)에 저장된 표현 중 두번째 ()에 해당하는 문자열 => group(2)에 저장

## 3. 메서드

| 메서드  | 설명                                                     |
| :------ | :------------------------------------------------------- |
| match   | 문자열의 처음부터 정규식과 매치되는지 조사               |
| search  | 문자열 전체를 검색하여 정규식과 매치되는지 조사          |
| findall | 정규식과 매치되는 모든 문자열(substring)을 리스트로 리턴 |
| split   | 패턴으로 나누기                                          |
| sub     | 패턴 대체하기                                            |

### 3-1. search()와 match()

- match()는 처음이 일치하지 않으면 None을 반환

- search()는 처음이 일치하지 않더라도 전체를 수색
- 또 하나의 특징은 두 함수 모두 원하는 것이 발견되면 수색을 멈춤

~~~python
source = "data makes future"
match = re.match("makes", source)
search = re.search("makes", source)

if match:
  print("match : ", match.group())
  
if search:
  print("search : ", search.group())

[Output]
search : makes
~~~

### 3-2. findall() 와 finditer()

- `findall()`은 정규식과 매칭되는 모든 문자열을 리스트 형식으로 반환

- `finditer()`도 매칭되는 모든 문자를 찾되, iterator객체로 반환

  객체의 값을 불러오려면 for문을 이용해 읽어들인다.

~~~python
p = re.compile('[a-z]+') # (a-z)가 1회 이상 반복
m1 = p.findall("Life is to short")
m2 = p.finditer("Life is to short")

print(m1)
print(type(m1))
print(m2)
print(type(m2))
~~~

~~~python
[OUTPUT]
['ife', 'is', 'to', 'short']
<class 'list'>
<callable_iterator object at 0x7f010c08b588>
<class 'callable_iterator'>
~~~

~~~python
for r in m2:
  if r:
    print(r)
>>> 출력결과
ife
is
to
short
~~~

## 4. 정규표현식, r' '의 의미

`p = re.compile(r'\\section')`

정규패턴식 앞에 `r`이 붙어 있는 경우가 많다. 파이썬 정규식에는 Raw string이라고 해서, 컴파일 해야 하는 정규식 Raw String(순수한 문자)임을 알려줄 수 있도록 하는 문법이다. 

만약 `p = re.compile('\section')`이라고 쓴다면 \s는 공백문자를 의미하는 [\t\n\r\f\v]이 되어버려 원하는 결과를 찾지 못한다. 이스케이프 \를 활용해 `\section`이라고 해주면 되지만, 파이썬은 특수하게 r을 사용하면 백슬래쉬 1개만 써도 두개를 쓴 것과 같은 효과를 갖는다.